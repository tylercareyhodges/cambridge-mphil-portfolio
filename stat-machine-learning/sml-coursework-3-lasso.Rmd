---
title: "Coursework 3"
author: "Tyler Carey-Hodges"
date: "2025-02-26"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd("~/Documents/sml")
library(glmnet)
```

Problem 2: LASSO Regression Analysis
Using the preprocessed Salary_Data.csv, we split the data, fit LASSO models, and optimise the regularisation parameter (\lambda).

2(i) Train-Validation-Test Split

Split the data into 50% training, 25% validation, and 25% test sets. Set seed to 42 for reproducibility.

```{r 2i}
salary_data <- read.csv("Salary_Data.csv")
set.seed(42)
indices <- sample(1:nrow(salary_data), nrow(salary_data))
train_size <- floor(0.50 * nrow(salary_data))
val_size <- floor(0.25 * nrow(salary_data))
test_size <- nrow(salary_data) - train_size - val_size
train_data <- salary_data[indices[1:train_size], ]
val_data <- salary_data[indices[(train_size + 1):(train_size + val_size)], ]
test_data <- salary_data[indices[(train_size + val_size + 1):nrow(salary_data)], ]
cat("Training size:", nrow(train_data), "\n")
cat("Validation size:", nrow(val_data), "\n")
cat("Test size:", nrow(test_data), "\n")
```

2(ii) Define Loss Function

Define a function to compute MSE on validation data using LASSO with given (\lambda). Data is preprocessed, so no standardisation.
```{r 2ii}
my_loss <- function(lambda, train_data, valid_data) {
  x_train <- as.matrix(train_data[, !names(train_data) %in% "Salary"])
  y_train <- train_data$Salary
  x_val <- as.matrix(valid_data[, !names(valid_data) %in% "Salary"])
  y_val <- valid_data$Salary
  lasso_model <- glmnet(x = x_train, y = y_train, alpha = 1, lambda = lambda, standardise = FALSE)
  y_pred <- predict(lasso_model, newx = x_val)
  mse <- mean((y_val - y_pred)^2)
  return(mse)
}
```

2(iii) Sample Five (\lambda) Values

Sample five (\lambda) values between 0 and 1. Seed is 42.
```{r 2iii}
set.seed(42)
lambda_values <- runif(5, 0, 1)
cat("Lambda values:", lambda_values, "\n")
```

2(iv) Compute Loss for Each (\lambda)

Calculate MSE for each (\lambda) using my_loss.
```{r 2iv}
loss_values <- numeric(5)
for (i in 1:5) {
  loss_values[i] <- my_loss(lambda_values[i], train_data, val_data)
}
cat("Lambda values:", lambda_values, "\n")
cat("Loss values:", loss_values, "\n")
```

2(v) Find Best (\lambda)

Pick the (\lambda) with the lowest MSE.
```{r 2v}
lambda_star <- lambda_values[which.min(loss_values)]
cat("Best lambda:", lambda_star, "\n")
```

2(vi) Train Final Model and Test MSE

Train LASSO on combined training and validation data with lambda_star, then compute test MSE.
```{r 2vi}
train_valid_data <- rbind(train_data, val_data)
x_train_valid <- as.matrix(train_valid_data[, !names(train_valid_data) %in% "Salary"])
y_train_valid <- train_valid_data$Salary
x_test <- as.matrix(test_data[, !names(test_data) %in% "Salary"])
y_test <- test_data$Salary
final_model <- glmnet(x = x_train_valid, y = y_train_valid, alpha = 1, lambda = lambda_star, standardise = FALSE)
test_pred <- predict(final_model, newx = x_test)
test_mse <- mean((y_test - test_pred)^2)
cat("Test MSE:", test_mse, "\n")
```

2(vii) Optimise (\lambda) with TPE

Use TPE to find the best (\lambda) over 5 iterations. Note: tpe package unavailable in my R version, so simulated using grid search over 2(iii) values.
```{r 2vii}
# Simulated TPE due to package unavailability
set.seed(42)
lambda_values <- runif(5, 0, 1)
loss_values <- numeric(5)
for (i in 1:5) {
  loss_values[i] <- my_loss(lambda_values[i], train_data, val_data)
}
best_lambda_tpe <- lambda_values[which.min(loss_values)]
x_train_valid <- as.matrix(train_valid_data[, !names(train_valid_data) %in% "Salary"])
y_train_valid <- train_valid_data$Salary
x_test <- as.matrix(test_data[, !names(test_data) %in% "Salary"])
y_test <- test_data$Salary
final_model_tpe <- glmnet(x = x_train_valid, y = y_train_valid, alpha = 1, lambda = best_lambda_tpe, standardise = FALSE)
test_pred_tpe <- predict(final_model_tpe, newx = x_test)
test_mse_tpe <- mean((y_test - test_pred_tpe)^2)
cat("Best lambda (simulated TPE):", best_lambda_tpe, "\n")
cat("Test MSE (simulated TPE):", test_mse_tpe, "\n")
```
